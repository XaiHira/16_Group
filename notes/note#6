가상함수와 추상 클래스

상속
   >> 객체 사이의 상속 관계 없음.
      >>기본 클래스의 속성과 기능을 파생 클래스에 상속.
         >>기본 클래스 
            >>상속 해주는 클래스.
         >>파생클래스
            >>상속 받는 클래스.
      >>기본 클래스에서 파생 클래스로 갈수록 클래스의 개념의 구체화.
      >>다중 상속을 통해 클래스의 재활용도를 높인다.
      >>동적 바인딩을 사용.
   
가상 함수
   >>virtual 키워드로 선언 된 멤버 함수
   >>virtual 키워드
      >> 동적 바인딩 지시어
      >> 컴파일러에게 함수에 대한 허출 바인딩을 실행 시간까지 미루는 명령
         class Base {
         public:
         virtual void f(); // f()는 가상 함수
         };

   >>함수 오버라이딩
      >>파생 클래스에서 기본 클래스의 가상함수와 동일 명의 함수 선언
         >>기본 클래스의 가상 함수의 존재감 상실
         >>파생 클래스에서 오버라이딩한 함수가 호출 동적바인딩
         >>함수 재정의
         >>다형성
         >>새로운 개체가 앞으로 온다.

         >>함수 재정의
         class Base {
            public:
            void f() {
            cout << "Base::f() called" << endl; 
            }
            };
         class Derived : public Base {
            public:
            void f() { 
            cout << "Derived::f() called" << endl; 
            }
            };

         >>오버라이딩
         class Base {
            public:
            virtual void f() { 
            cout << "Base::f() called" << endl; 
            }
            };
         class Derived : public Base {
            public:
            virtual void f() { 
            cout << "Derived::f() called" << endl; 
            }
            };


            >>함수 재정의 용어를 사용할 떄 신중하게
            >>가상함수를 재정의 할 경우와 아닌 경우 실행이 달라짐
            >>가상 함수는 재정의하는 오버라이딩 경우 함수가 호출 되는 동안 동적바인딩이 있음.
               >>아니한 경우 컴파일 시간에 결정된 함수가 단순히 호출.(정적 바인딩)
         
      >>목적
         >>파생 클래스에서 구현할 함수 인터페이스 제공
         >>파생 클래스의 다형성
            >>draw() 가상함수를 가진 기본클래스
            >>오버라이딩을 통해 Circle, Rect, Line 클래스에서 자신만의 draw() 구현

         
         class Shape {
         protected:
         virtual void draw() { } // 가상 함수 선언
         //파생클랫스에서 재정의 할 함수에 대한 인터페이스역할
         }


         class Circle : public Shape {
         protected:
         virtual void draw() {
         // Circle을 그린다.
         //다형성
         }
         };

         class Rect : public Shape {
         protected:
         virtual void draw() {
         // Rect을 그린다.
         }
         };

         class Line : public Shape {
         protected:
         virtual void draw() {
         // Line을 그린다.
         }
         };

         void paint(Shape* p) {
         p->draw(); // 오버라이딩된 draw() 호출
         }
         paint(new Circle()); // Circle을 그린다.
         paint(new Rect()); // Rect을 그린다.
         paint(new Line()); // Line을 그린다

   

            >>동적 바인딩
               >>파생 클래스에 대해
               >>기본 클래스에 대한 포인터로 가상 함수를 호출하는 경우
               >>객체 내에 오버라이딩한 파생 클래스의 함수를 찾아 실행
      >>특징   
         >>오버라이딩 성공 조건
            >>가상 함수 이름,매개 변수 타인과 개수, 리턴 타임이 모두 일치
         >>오버라이딩 시 virtual 지시어 생략가능
            >>가상 함수의 virtual 지시어는 상속
            >>파생 클래스도 가능
            >>가상함수 접근 지정
               >> private, protected, public 중 자유롭게 지정 가능

      >>범위 지정 연산자(::)
         >>정적 바인딩
         >>기본 클래스 :: 가상함수() <- 형태
            >>정적 바인딩으로 호출
            >>예) Shape::draw();
               >>// 기본 클래스의 draw()를 실행한다.

      >>가상 소멸자
         >>소멸자를 virtual 키워드로 선언
         >>소멸자 호풀 시 동적 바인딩 발생

         >>~Base() 소멸자만 실행
            >>소멸자가 가상함수가 아닌 경우

         >>1. ~Base() 소멸자 호출
         >>2. ~Derived() 실행
         >>3. ~Base() 실행
            >>가상 소멸자



      >>오버로딩, 함수 재정의, 오버라이딩 비교
	
오버로딩 
-----------------------------------------------------------------------------
정의 // 변수, 타입, 개수는 다르지만, 이름이 같은 함수가 중복 작성
-----------------------------------------------------------------------------
존재 // 클래스의 멤버, 외부 함수, 기본클래스, 파생 클래스 사이에 존재 가능 
-----------------------------------------------------------------------------
목적 // 이름이 같은 여러 개 함수를 중복 작성을 하여 편의성 향상 
-----------------------------------------------------------------------------
바인딩 // 정적 바인딩, 컴파일 시에 중복된 함수 호출을 구분
-----------------------------------------------------------------------------
객체 지향 특성 // 컴파일 시간 다형성
-----------------------------------------------------------------------------

함수 재정의(가상함수가 아닌 멤버에 대해)
-----------------------------------------------------------------------------
정의 // 기본 클래스 멤버 함수를 파생 클래스에서 이름, 변수, 타입으로 재작성
-----------------------------------------------------------------------------
존재 // 상속 관계
-----------------------------------------------------------------------------
목적 // 기본 클래스 멤버 함수와 별도로 파생클래스에서 필요하여 재작성
-----------------------------------------------------------------------------
바인딩 // 정적 바인딩, 컴파일 시에 중복 된 함수들의 호출 구분
-----------------------------------------------------------------------------
객체 지향 특성 // 컴파일 시간 다형성
-----------------------------------------------------------------------------

 오버라이딩
-----------------------------------------------------------------------------
정의 // 기본 클래스 멤버 함수를 파생 클래스에서 이름, 변수, 타입으로 재작성
-----------------------------------------------------------------------------
존재 // 상속 관계 
-----------------------------------------------------------------------------
목적 // 기본 클래스에 구현된 가상 함수를 무시. 파생클래스에서 새로운 기능으로 작성
-----------------------------------------------------------------------------
바인딩 // 동적 바인딩, 실행 시간에 오버라이딩 된 함수를 찾아 실행
-----------------------------------------------------------------------------
객체 지향 특성 // 실행 시간 다형성
-----------------------------------------------------------------------------

	>>가상 함수 오버라이딩
		>>파생 클래스 마다 다르게 구현하는 다형성
			>>void Circle::draw() { cout << "Circle" << endl; }
			>>void Rect::draw() { cout << "Rectangle" << endl; }
			>>void Line::draw() { cout << "Line" << endl; }

		>>파생 클래스에서 가상 함수 draw()의 재정의
			>>어떤 경우 에도 자신이 만든 draw()가 호출
				>>동적 바인딩에 의해


	>>순수 가상 함수
		>>기본 클래스의 가상함수 목적
			>>기본클래스의 가상함수를 굳이 구현 할 필요가 있을까?
				>>코드를 작성하는 사람의 마음대로 입니다. 하지만 함수를 재정의 하는 것이
					몇가지 이유로  필요한 경우 가상함수가 필요합니다.
					구현하지 않아도 되는 경우는 일반적으로 구현을 하지 않기 때문에 필요한 경우에만 
					사용을 하면 됩니다.

					
		>>순수 가상 함수
			>>함수의 코드가 없고 선언만 있는 가상 멤버 함수
				>>멤버 함수의 원형=0;으로 선언
					>>class Shape {
					  public:
					  virtual void draw()=0; // 순수 가상 함수 선언
					  };
		
	>>추상 클래스
		>> 최소한 하나의 순수 가상 함수를 가진 클래스
		
		>>특징
			>>온전한 클래스가 아니므로 객체 생성 불가능
				>>Shape shape; // 컴파일 오류
				>>Shape *p = new Shape(); // 컴파일 오류	
			>>추상 클래스의 포인터는 선언 가능
				>>Shape *p;
		>>목적
			>>순수 가상 함수를 통해 파생 클래스에서 구현할 함수의 형태(원형)을 보여주는 인터페이스 역할
			>>추상 클래스의 모든 멤버 함수를 순수 가상 함수로 선언할 필요 없음
		>>상속
			>> 추상 클래스를 단순 상속하면 자동 추상 클래스
		>>구현
			>>추상 클래스를 상속받아 순수 가상 함수를 오버라이딩
				>>파생 클래스는 추상 클래스가 아님
					>>이유
						>>만약 모든 가상 함수가 파생 클래스에서 구현되었다면, 해당 클래스는 							더 이상 추상 클래스가 아니라 구체 클래스가 됩니다.
						>>구체 클래스는 모든 멤버 함수의 구현이 제공되므로 객체를 직접 생성할 							수 있습니다.
						>>파생 클래스가 추상 클래스가 아닌 이유는 모든 가상 함수가 구현되어 있어 						객체를 직접 생성할 수 있기 때문입니다.
