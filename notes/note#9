Ch12. C++ 파일 입출력
>>텍스트 파일과 바이너리 파일
	>>텍스트 파일
		>>문자 만으로 구성된 파일
		>>사람들이 사용하는 글자 혹은 문자들로만 구성되는 파일
			>>알파벳, 한글, 숫자, 특수문자, 문자로 이루어지는 것
			>>\n, \t도 특수문자
		>>각 문자마다 문자코드(이진수)할당
			>>ASCII코드, 유니코드
		>>종류
			>>txt, HTML, XML. C++소스 파일, C소스 파일, 자바 소스 파일
		>>Enter Key
			>>Enter KEY를 입력을 하면 텍스트 파일에는 \r, \n의 두코드가 기록
	>>바이너리 파일
		>>문자, 그림, 표, 사운드, 동영상, 등으로 잡하게 구성된 문서
		>>문자로 표현되지 않는 바이너리 데이터가 기록된 파일
			>>이미지, 오디오, 그래픽, 컴파일된 코드는 문자로 표현되지 않음
		>>텍스트 파일의 각 바이트를 문자로 해석
		>>바이너리 파일의 각 바이트는 문자로 해석되지 않는 것도 있음
			>>각 바이트의 의미는 파일을 만든 응용프로그램 만이 해석이 가능
		>>종류
			>>jpeg, bmp, png 등 이미지 파일
			>>mp3, flag 등 오디오 파일
			>>hwp, doc, ppt, 등 확장자를 가진 멀티미디어 문서 파일
			>>odj, exe등의 확장자를 가진 컴파일된 코드나 실행 파일
	>>파일 입출력
		>>ifsteam - 파일읽기
		>>fstream - 하나의 파일에 대해 읽기와 쓰기를 동시에 할 떄 사용
		>>ofstream - 파일 쓰기 시에 사용

	>>파일 입출력 스트림은 파일을 프로그램과 연결
		>> (>>)연산자와 isteam의 get, read()함수
			>>연결된 장치부터 읽는 함수
			>>키보드에 연결되면 키 입력을, 파일에 연결되면 파일에 입력
		>> (<<)연산자와 ostream의 put(),write()함수
			>>연결된 장치에 쓰는 함수
			>>스크린에 연결되면 화면에, 파일에 연결되면 파일에 출력
	>>헤더 파일과 namespace
		>>C++파일 입출력 라이브러리 사용
			>>fstream 헤더 파일과 std 이름 공간의 선언 필요
				>> #include <fstream>
				    using namespace std
	>>파일 입출력 모드 : 텍스트 I/O 와 바이너리 I/O의 두방식
		>>입출력 방식
			>>텍스트 I/O와 바이너리 I/O의 두방식
				>>C++ 파일 입출력 클래스(ifstream, ofstream, fstream)는 두방식 지원
		>>텍스트 I/O
			>>문자 단위로 파일에 쓰기, 파일에서 읽기
				>>문자를 기록학고, 읽은 바이트를 문자로 해석
			>>텍스트 파일에만 적용
		>>바이너리 I/O
			>>바이트 단위로 파일에 쓰기, 파일에서 읽기
				>>데이터를 문자로 해석하지 않고 있는 그대로 기록하거나 읽음
			>>텍스트 파일과 바이너리 파일 모두 입출력 가능
		>>텍스트I/O와 바이너리I/O 입출력 시 차잊점
			>>개형 문자(\n)을 다루는데 있음(뒤에서 설명)
	>>file mode
		>>파일 입출력에 대한 구체적인 작업 형태에 대한 지정
			>>파일에서 읽을 작업을 할 것 인지, 쓰기 작업을 할 것인지
			>>기존 파일의 데이터를 모두 지우고 쓸 것인지, 파일의 끝 부분에 쓸 것인지
			>>텍스트I/O 방식인지 바이너리 I/O 방식인지
		>>파일 모드 지정 - 파일 열 때
			>>open("파일이름", 파일모드)
			>>ifstream("파일이름", 파일모드)
			>>ofstream("파일이름", 파일모드)	
		>>SetUp
			>>void open(const char * filename, ios::openmode mode)
				>>mode로 지정된 파일 모드로 filename의 팡일을 연다.
			>>student.txt 파일을 예시
				>>처음부터 읽고자 하는 경우
					>>ifstream fin;
					  fin.open("student.txt");
					>>ifstream fin;
					  fin.open("student.txt", ios::in);
				>>끌에 데이터를 저장하는 경우
					>>ofsream fout;
					  fout.open("student.txt", ios::out|ios::app);
					  fout << "tel:0104447777";// 기존의 student.txt 끝에 "tel:0104447777"을 추가하여 저장
			>>바이너리 I/O로 data.din 파일을 기록 하는 경우
				>>fstream fbinout;
				  fbinout.open("data.bin", ios::out|ios::binary);
				  char buf[128];
				  ...
				  fbinout.write(buf,128);//buf에 있는 128bit 파일에 기록
	>>get()와 EOF
		>>파일의 끝을 만나면 읽기를 멈춰야 하는데 get()은 파일의 끝을 어떻게 인식할까?
			>>파일의 끝에 도달하면 -1을 반환하고, 이를 EOF 상수와 비교하여 파일 읽기를 멈추게 됩니다.
	>>텍스트 파일의 라인 단위 읽기
		>>istream의 getline(char* line, int n) 함수 이용
		>>getline(ifstream& fin, string& line) 함수 이용
	>>바이너리 I/O
		>>데이터의 바이너리 값을 그대로 파일에 저장하거나, 파일의 바이너리 값을 그대로 읽어서 변수나 버퍼에 저장하는 방식
		>>텍스트 파일이든 바이너리 파일이든 바이너리 I/O로 입출력가능
		>>모드 열기
			>>ios::binary 모드 속성 사용
			>>ios::binary가 설정되지 않으면 디폴트가 텍스트 I/O
	>>read()/write()로 블록 단위 파일 입출력
		>>get()/put()
			>>문자 혹은 바이트 단위로 파일 입출력
		>>read()/write()
			>>블록 단위로 파일 입출력

>>텍스트 I/O와 바이너리 I/O 차이점
	>>파일의 끝을 처리하는 방법에는 차이 없다. -텍스트 I/O 든 바이너리 I/O 든 파일의 끝을 만나면 EOF 리턴하기 떄문에.
	>>개행 문자 ‘\n’를 읽고 쓸 때 서로 다르게 작동한다.
	

>>스트림 상태
	>>파일 입출력이 진행되는 동안 스트림(열어 놓은 파일)에 관한 입출력 오류 저장
		>>스트림 상태를 저장하는 멤버 변수 이용
 

>>임의 접근과 파일 포인터
	>>C++ 파일 입출력 방식
		>>순차 접근
			>>읽은 다음 위치에서 읽고, 쓴 다음 위치에 쓰는 방식
			>>디폴트 파일 입출력 방식
		>>임의 접근
			>>파일 내의 임의의 위치로 옮겨 다니면서 읽고 쓸 수 있는 방식
			>>파일 포인터를 옮겨 파일 입출력
			>>파일 포인터(file pointer)
				>>파일은 연속된 바이트의 집합
		>>파일 포인터
			>>파일에서 다음에 읽거나 쓸 위치를 표시하는 특별한 마크
		>>C++는 열려진 파일마다 두 개의 파일 포인터 유지
			>>get pointer : 파일 내에 다음에 읽을 위치
			>>put pointer : 파일 내에 다음에 쓸 위치

			

